import bmp from 'bmp-js';
import ILoader from './ILoader';
import Header from './utils/Header';
import EncodedOutput from './utils/EncodedOutput';
import { TYPE_ID_BITS_SIZE, loadersTypeId } from '@voyager-edsound/constants';
import {
  sliceTextInChunks,
  decimalToBinary,
  readBitsChunk,
  binaryToDecimal,
  checkTypeId,
  hexToBpp,
  bppToHex,
} from '@voyager-edsound/core';

class Bitmap2bitspp implements ILoader<Buffer> {
  private BPP = 2;
  public header: Header = new Header(loadersTypeId.BITMAP_2BITS_PP);

  /**
   * Bitmap1bytepp Loader - encoder and decoder. This will take only 1 byte of color and
   * generate a bitmap with 24 bytes containing the gray factor. The encoded
   * data will store only 1 byte per pixel.
   *
   * The header is storing one parameter:
   * typeId: 8 bits
   * width: 16 bits
   * height: 16 bits
   * imageBits: infinity (the rest of bits)
   */
  constructor() {}

  /**
   * Get a 24 bits bitmap and converts it to 2 bits per pixel (4 tons of grey)
   * format and generates the bits to be stored on audio.
   *
   * @param imageBuffer 24 bits Bitmap buffer
   */
  encode(imageBuffer: Buffer): EncodedOutput {
    let output = '';
    const bmpData = bmp.decode(imageBuffer);
    const { width, height } = bmpData;

    // Header
    const widthBits = decimalToBinary(width, 16); // 16 bits
    const heightBits = decimalToBinary(height, 16); // 16 bits
    this.header.addBits(widthBits);
    this.header.addBits(heightBits);

    // Convert image data to bits (Buffer)
    const imageData = bmpData.getData();
    // Stores only the red as factor to grey scale
    for (let y = 3; y < imageData.length; y += 4) {
      output += decimalToBinary(
        hexToBpp(imageData.readUInt8(y), this.BPP),
        this.BPP
      );
    }

    return new EncodedOutput(this.header, output);
  }

  /**
   * Decodes the Bitmap information and return a Bitmap 2 bits per pixel buffer (4 tons of grey).
   * However, the final decoded file will be a 24 Bitmap file.
   * @param bitsSequence Bits
   */
  decode(bitsSequence: string) {
    // Check typeId
    const typeIdCheck = checkTypeId(
      bitsSequence,
      this.header.getHeaderTypeId()
    );
    if (typeIdCheck !== null && typeIdCheck === false) {
      throw new Error(
        'This is not a audio file generated by Bitmap2bitspp loader.'
      );
    }

    const additionalHeaderBits = 32;
    const headerBitsSize = TYPE_ID_BITS_SIZE + additionalHeaderBits;
    let output: Buffer;

    let width: number; // 16 bits
    let height: number; // 16 bits
    let imageBits: string; // Rest of Bits

    // Read after have enough bits loaded to read the header bits
    if (bitsSequence.length >= headerBitsSize) {
      width = binaryToDecimal(
        readBitsChunk(bitsSequence, 16, TYPE_ID_BITS_SIZE)
      );
      height = binaryToDecimal(
        readBitsChunk(bitsSequence, 16, TYPE_ID_BITS_SIZE + 16)
      );

      imageBits = readBitsChunk(
        bitsSequence,
        null,
        TYPE_ID_BITS_SIZE + additionalHeaderBits
      );

      // Convert bits to buffer with image data
      let imageDataBitsArray = sliceTextInChunks(imageBits, 2);

      // Add the QUAD bits and BLUE, GREEN and RED as the factor saved on the encode
      const imageDataWithQBGR: number[] = [];
      for (let y = 0; y < imageDataBitsArray.length; y++) {
        // The fusion of these data will generate gray scale according
        // to the factor registered on imageDataBitsArray[y]
        const color = bppToHex(
          binaryToDecimal(imageDataBitsArray[y]),
          this.BPP
        );
        imageDataWithQBGR.push(
          0, // QUAD
          color, // BLUE
          color, // GREEN
          color // RED
        );
      }

      const bmpData = {
        data: Buffer.from(imageDataWithQBGR),
        width,
        height,
      };

      const rawData = bmp.encode(bmpData);

      output = rawData.data;
    } else {
      output = Buffer.alloc(0);
    }

    return output;
  }
}

export default Bitmap2bitspp;
