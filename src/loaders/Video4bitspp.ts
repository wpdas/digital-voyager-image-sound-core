import ILoader from './ILoader';
import Header from './utils/Header';
import EncodedOutput from './utils/EncodedOutput';
import { loadersTypeId, TYPE_ID_BYTE_SIZE } from '../constants';
import Bitmap4bitspp from './Bitmap4bitspp';

interface DecodeChunkProps {
  data: Uint8ClampedArray;
  imageData: Uint8Array;
  bytesChunk: number;
}

class Video4bitspp
  implements ILoader<Array<EncodedOutput>, DecodeChunkProps, void> {
  public header: Header = new Header(loadersTypeId.BITMAP_4BITS_PP);

  /**
   * Video4bitspp Loader
   *
   * The header is storing one parameter:
   * typeId: 1 byte
   * width: 2 bytes
   * height: 2 bytes
   * imageBits: infinity (the rest of bits)
   */
  constructor() {}

  encode(bitmap4bitsEncodedOutputFrames: Array<EncodedOutput>): EncodedOutput {
    const sequencialFrameBytes: Array<number> = [];
    const emptyLoader: Bitmap4bitspp = new Bitmap4bitspp();

    for (let i = 0; i < bitmap4bitsEncodedOutputFrames.length; i++) {
      const currentEncodedBytes: Uint8Array = emptyLoader.getSampleData(
        bitmap4bitsEncodedOutputFrames[i].bytes
      );
      for (let y = 0; y < currentEncodedBytes.length; y++) {
        sequencialFrameBytes.push(currentEncodedBytes[y]);
      }
    }

    return new EncodedOutput(this.header, sequencialFrameBytes);
  }

  /**
   * Decodes the Bitmap information and return a Bitmap 4 bits per pixel buffer (16 tons of grey).
   * However, the final decoded file will be a 24 Bitmap file.
   * @param bytes bytes containing the data
   */
  decode(bytes: Uint8Array) {
    // Check typeId
    const typeId = bytes[0];
    if (typeId !== this.header.getHeaderTypeId()) {
      throw new Error(
        'This is not a audio file generated by Video4bitspp loader.'
      );
    }

    // empty output - TEMP
    // Should return list of EncodedOutputs
    // TODO: use FFmpeg to convert common videos to this loader kind video
    // TODO: create another method to get this list and generates a video using FFmpeg
    const output: Array<EncodedOutput> = [
      new EncodedOutput(new Header(9999), []),
    ];

    return output;
  }

  /**
   * Get only sample data from bytes. Bytes must be delivered by Reader
   * @param bytes bytes containing the data
   */
  getSampleData(bytes: Uint8Array) {
    const additionalHeaderBits = 4;
    const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBits;
    return bytes.slice(headerBitsSize);
  }

  decodeChunk() {}
}

export default Video4bitspp;
