import bmp from 'bmp-js';
import ILoader from './ILoader';
import Header from './utils/Header';
import EncodedOutput from './utils/EncodedOutput';
import numberToUint8 from '../core/numberToUint8';
import uint8ToNumber from '../core/uint8ToNumber';

import { loadersTypeId, TYPE_ID_BYTE_SIZE } from '../constants';

interface DecodeChunkProps {
  totalSamplesSize: number;
  data: Uint8ClampedArray;
  imageData: Uint8Array;
  bytesChunk: number;
}

class Bitmap24bitsTrueColor implements ILoader<Buffer, DecodeChunkProps, void> {
  public header: Header = new Header(loadersTypeId.BITMAP);

  /**
   * Bitmap 24bits True Color Loader - encoder and decoder.
   *
   * The header is storing one parameter:
   * typeId: 1 byte
   * width: 2 bytes
   * height: 2 bytes
   * imageBits: infinity (the rest of bits)
   */
  constructor() {}

  /**
   * Get a 24 bits bitmap and converts it to 24 bits per pixel (RGB color, ignoring alpha)
   * format and generates the bits to be stored on audio.
   *
   * @param imageBuffer 24 bits Bitmap buffer
   */
  encode(imageBuffer: Buffer): EncodedOutput {
    const bmpData = bmp.decode(imageBuffer);
    const { width, height } = bmpData;

    // Header
    const widthBits = numberToUint8(width, 2); // 2 bytes
    const heightBits = numberToUint8(height, 2); // 2 bits
    this.header.addBytes(widthBits);
    this.header.addBytes(heightBits);

    const redSamples: Array<number> = [];
    const greenSamples: Array<number> = [];
    const blueSamples: Array<number> = [];

    // Get image pixels buffer
    const imageData = bmpData.getData();

    for (let y = 3; y < imageData.length; y += 4) {
      blueSamples.push(imageData.readUInt8(y - 2));
      greenSamples.push(imageData.readUInt8(y - 1));
      redSamples.push(imageData.readUInt8(y));
    }

    return new EncodedOutput(
      this.header,
      blueSamples.concat(greenSamples, redSamples)
    );
  }

  /**
   * Decodes the Bitmap information and return a Bitmap 24 bits per pixel buffer (RGB color).
   * However, the final decoded file will be a 24 Bitmap file.
   * @param bytes bytes containing the data
   */
  decode(bytes: Uint8Array) {
    // Check typeId
    const typeId = bytes[0];
    if (typeId !== this.header.getHeaderTypeId()) {
      throw new Error(
        'This is not a audio file generated by Bitmap24bitsTrueColor loader.'
      );
    }

    const additionalHeaderBits = 4;
    const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBits;

    let output: Buffer;
    let width: number; // 2 bytes
    let height: number; // 2 bytes

    // Read after have enough bytes loaded to read the header bytes
    if (bytes.length >= headerBitsSize) {
      width = uint8ToNumber([bytes[1], bytes[2]]);
      height = uint8ToNumber([bytes[3], bytes[4]]);

      // Bitmap byte array
      const bitmapDataByteArray: Array<number> = [];
      const imageBytes = bytes.slice(headerBitsSize);
      const colorSamplesSize = imageBytes.length / 3; // (RGB)

      for (let y = 0; y < colorSamplesSize; y++) {
        // QUAD, BLUE, GREEN, RED (QBGR)
        bitmapDataByteArray.push(
          0,
          imageBytes[y],
          imageBytes[y + colorSamplesSize],
          imageBytes[y + colorSamplesSize * 2]
        );
      }

      const bmpData = {
        data: Buffer.from(bitmapDataByteArray),
        width,
        height,
      };

      const rawData = bmp.encode(bmpData);

      output = rawData.data;
    } else {
      output = Buffer.alloc(0);
    }

    return output;
  }

  /**
   * Get only sample data from bytes. Bytes can be delivered by Reader
   * @param bytes bytes containing the data
   */
  getSampleData(bytes: Uint8Array) {
    const additionalHeaderBits = 4;
    const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBits;
    return bytes.slice(headerBitsSize);
  }

  private position = 0;

  /**
   * Process every file bytes and converts each value to an RGBA (integers in the range 0 to 255) that'll
   * be put into a slot of a imageData (Uint8ClampedArray). Each 4 slots represents an RGBA pixel.
   *
   * @param totalSamplesSize Sample bytes length (bytes data without wav header and loader header)
   * @param data one-dimensional array containing the data in RGBA order, as integers in the range 0 to 255. This is provided by a Canvas context.
   * @param imageBuffer Bitmap wav data
   * @param bytesChunk The amount of bytes that must be read in this cycle
   */
  decodeChunk({
    totalSamplesSize,
    data,
    imageData,
    bytesChunk,
  }: DecodeChunkProps) {
    const colorSamplesSize = totalSamplesSize / 3;
    for (let y = 0; y < bytesChunk; y++) {
      // BLUE, GREEN, RED (BGR) - The same way this bitmap is encoded
      if (this.position <= colorSamplesSize) {
        data[this.position * 4 + 2] = imageData[this.position]; // Blue -
        data[this.position * 4 + 3] = 255;
      } else if (
        this.position > colorSamplesSize &&
        this.position <= colorSamplesSize * 2
      ) {
        data[this.position * 4 + 1 - colorSamplesSize * 4] =
          imageData[this.position]; // Green -
      } else if (
        this.position > colorSamplesSize * 2 &&
        this.position <= colorSamplesSize * 3
      ) {
        data[this.position * 4 - colorSamplesSize * 2 * 4] =
          imageData[this.position]; // Red -
      }

      this.position++;
    }
  }
}

export default Bitmap24bitsTrueColor;
