import bmp from 'bmp-js';
import ILoader from './ILoader';
import Header from './utils/Header';
import EncodedOutput from './utils/EncodedOutput';
import { loadersTypeId, TYPE_ID_BYTE_SIZE } from '@voyager-edsound/constants';
import { numberToUint8, uint8ToNumber } from '@voyager-edsound/core';

class Bitmap8bitspp implements ILoader<Buffer> {
  public header: Header = new Header(loadersTypeId.BITMAP_8BITS_PP);

  /**
   * Bitmap1bytepp Loader - encoder and decoder. This will take only 1 byte of color and
   * generate a bitmap with 24 bytes containing the gray factor. The encoded
   * data will store only 8 bits per pixel.
   *
   * The header is storing one parameter:
   * typeId: 1 byte
   * width: 2 bytes
   * height: 2 bytes
   * imageBits: infinity (the rest of bits)
   */
  constructor() {}

  /**
   * Get a 24 bits bitmap and converts its to 8 bits per pixel (256 grey tons) format and
   * generates the bits to be stored on audio.
   *
   * @param imageBuffer 24 bits Bitmap buffer
   */
  encode(imageBuffer: Buffer): EncodedOutput {
    const bmpData = bmp.decode(imageBuffer);
    const { width, height } = bmpData;

    // Header
    const widthBits = numberToUint8(width, 2); // 2 bytes
    const heightBits = numberToUint8(height, 2); // 2 bits
    this.header.addBytes(widthBits);
    this.header.addBytes(heightBits);

    // Get image pixels buffer
    const imageData = bmpData.getData();
    let bitmapByteArray: Array<number> = [];

    // Stores only the red as factor to grey scale
    for (let y = 3; y < imageData.length; y += 4) {
      bitmapByteArray.push(imageData.readUInt8(y));
    }

    return new EncodedOutput(this.header, bitmapByteArray);
  }

  /**
   * Decodes the Bitmap information getting a Bitmap 8 bits per pixel buffer (256 grey tons).
   * However, the final decoded file will be a 24 Bitmap file.
   * @param bytes bytes containing the data
   */
  decode(bytes: Uint8Array) {
    // Check typeId
    const typeId = bytes[0];
    if (typeId !== this.header.getHeaderTypeId()) {
      throw new Error(
        'This is not a audio file generated by Bitmap8bitspp loader.'
      );
    }

    const additionalHeaderBits = 4;
    const headerBitsSize = TYPE_ID_BYTE_SIZE + additionalHeaderBits;

    let output: Buffer;
    let width: number; // 2 bytes
    let height: number; // 2 bytes

    // Read after have enough bytes loaded to read the header bytes
    if (bytes.length >= headerBitsSize) {
      width = uint8ToNumber([bytes[1], bytes[2]]);
      height = uint8ToNumber([bytes[3], bytes[4]]);

      // Bitmap byte array
      const bitmapDataByteArray: Array<number> = [];
      // Generate bitmap buffer following the way below
      bytes.slice(headerBitsSize).forEach((byte) => {
        // QUAD, BLUE, GREEN, RED (QBGR)
        bitmapDataByteArray.push(0, byte, byte, byte);
      });

      const bmpData = {
        data: Buffer.from(bitmapDataByteArray),
        width,
        height,
      };

      const rawData = bmp.encode(bmpData);

      output = rawData.data;
    } else {
      output = Buffer.alloc(0);
    }

    return output;
  }
}

export default Bitmap8bitspp;
